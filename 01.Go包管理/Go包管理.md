在go中，通过包（package）来组织代码。下面看看go中的包，以及相关的概念。



### Go工作空间

go编译⼯具对源码目录有严格要求，通常一个go的源码会被放在一个工作空间(workspace)中。  

每个⼯作空间必须由`bin`、`pkg`、`src`三个目录录组成，工作空间需要被添加到`GOPATH`环境变量列表中才能正常工作。

- bin：通过`go install`安装的go包目录
- pkg：`go build`⽣成静态库(*.a)的目录
- src：项目的源码目录



### Go中的包

在go中，所有的代码都是通过包（package）进行组织。对于go中的包：

- 源⽂件头部以`package name`声明包名
- 包可以由同⼀目录下的多个源码⽂件组成
- 可执⾏⽂件必须包含`package main`，⼊⼝函数`main()`
- 包中成员以名称⾸字⺟⼤⼩写决定访问权限
	- ⾸字⺟⼤写，可被包外访问
	- ⾸字⺟⼩写，仅包内成员可以访问



### 包的命名

包的命名，遵循简洁、小写、以及go文件所在目录同名的原则，这样就便于我们引用，书写以及快速定位查找。

比如go自带的http这个包，它这个http目录下的所有go文件都属于这个http包，所以我们使用http包里的函数、接口的时候，导入这个http包就可以了。例如：

	package main
	
	import "net/http"
	
	func main() {
		http.ListenAndServe("127.0.0.1:7777", handler);
	}

从上面例子可以看到，导入的是`net/http`，这在go里叫做全路径，因为`http`包在`net`包里面，`net`是最顶级的包，所以必须使用全路径导入，go编译程序才能找到`http`这个包，和文件系统的目录路径是一样的。

因为有了全路径，所以命名的包名可以和其他库的一样，只要它们的全路径不同就可以了，使用全路径的导入，也增加了包名命名的灵活性。



### main包

当把一个go文件的包名声明为`main`时，就等于告诉go编译程序，这个是一个可执行的程序，那么go编译程序就会尝试把它编译为一个二进制的可执行文件。一个`main`的包，一定会包含一个`main()`函数

	// hello/halo.go
	
	package main
	
	import "fmt"
	
	func main() {
	    fmt.Println("Hello Go!")
	}

该go文件叫`halo.go`，放在`$GOPATH/src/hello`目录下，那么我们在这个目录下执行`go build`命令就会生成二进制的可执行文件，在window系统下生成的是`halo.exe`，在Unix，MAC和Linux下生成的是`halo`，通过终端执行它，就可以看到控制台打印的:

	Hello Go!



### 导入包

要想使用一个包，必须先导入它才可以使用，Go语言提供了`import`关键字来导入一个包。具体使用形式如下：

	import "相对目录/包主⽂件名"

当需要导入多个包的时候，Go语言还提供了导入块：

	import (
		"net/http"
		"fmt"
	)

在导⼊时，可指定包成员访问⽅式。⽐如对包重命名，以避免同名冲突

	import "will/test" 	   // 默认模式: test.A
	
	import M "will/test"   // 包重命名: M.A
	
	import . "will/test"   // 简便模式: A
	
	import _ "will/test"   // ⾮导⼊模式: 仅让该包执⾏初始化函数



### 包的`init`函数

Go包中的`init`函数又叫做初始化函数，有以下特点：

- 每个源⽂件都可以定义⼀个或多个初始化函数
- 编译器不保证多个初始化函数执⾏次序
- 初始化函数在单⼀线程被调⽤，仅执⾏⼀次
- 初始化函数在包所有全局变量初始化后执⾏
- 在所有初始化函数结束后才执⾏ main.main
- ⽆法调⽤初始化函数


`init`函数通常用来做初始化变量、设置包或者其他需要在程序执行前的引导工作。比如前面使用`_`空标志符来导入一个包的目的，就是想执行这个包里的`init`函数。