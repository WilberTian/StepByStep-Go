Go语言是一种静态类型的编程语言，所以在编译器进行编译的时候，就要知道每个值的类型，这样编译器就知道要为这个值分配多少内存，并且知道这段分配的内存表示什么。

Go中常用的数据类型如下：

类型 | ⻓度 | 默认值 | 说明
--------------|----------|----------|----------
bool          | 1        | false
byte          | 1        | 0        | uint8
rune          | 4        | 0        | Unicode Code Point, int32
int, uint     | 4 or 8   | 0        | 32 或 64 位
int8, uint8   | 1        | 0        | -128 ~ 127, 0 ~ 255
int16, uint16 | 2        | 0        | -32768 ~ 32767, 0 ~ 65535
int32, uint32 | 4        | 0        |
int64, uint64 | 8        | 0        |
float32       | 4        | 0.0      |
float64       | 8        | 0.0      |
array         |          |          | 值类型
struct        |          |          | 值类型
string        |          | ""       | UTF-8 字符串
slice         |          | nil      | 引⽤类型
map           |          | nil      | 引⽤类型
channel       |          | nil      | 引⽤类型
interface     |          | nil      | 接⼝
function      |          | nil      | 函数



### 值类型

在Go数据类型中，大部分是值类型，**对于值类型的赋值和传参都会产生一份新的拷贝**。

特别需要注意的是，Go中的数组和结构都是值类型。



### 引用类型

在Go语言中，引用类型有`slice`、`map`、接口、函数类型以及通道(channel)，对于引用类型对象的修改可以影响到任何引用到它的变量。

引用类型之所以可以引用，是因为创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因。



### 自定义类型

在Go语言中，可以使用`type`关键字，基于一个现有的类型定义一个新的类型。

    func main() {
        type bigint int64
        var x bigint = 100
        
        fmt.Println(x)
    }

新类型不是原类型的别名，除拥有相同数据存储结构外，它们之间没有任何关系，不会持有原类型任何信息。所以对于Go这种强类型语言，它们是不能相互赋值的。

    func main() {
        x := 1234
        var b bigint = bigint(x)     // 必须显式转换
        var b2 int64 = int64(b) 
    }

